# 2. Versioning and deployments

**Date:** 2020-02-21

## Context

TDR will have multiple deployment environments: integration, staging and
production. We want to be able to deploy new versions of our services to each
environment in turn.

## Decision

Configure each project's build and Jenkinsfile so that when code is merged to
master and the tests pass, Jenkins runs the following steps:

1. Create a git tag with a version number based on the Jenkins build number, at
   the commit that master is pointing to
2. Push the version tag to GitHub
3. If the repo is deployed as a Docker image (such as the [consignment
   API][tdr-api] or the [frontend]), build the Docker image, tag it
   with the same version number and push it to the Docker image repository
   (currently Docker Hub, but may soon be AWS ECR)

This version is now available to deployed to each environment in turn.

The master build should start an automated deployment to the Integration
environment, passing the version tag as a parameter. The deployment build will:

1. Pull the Docker image tagged with the given version tag
2. Retag the Docker image with the environment name (e.g. "intg")
3. Trigger an update in AWS, e.g. by calling the AWS API to restart the ECS
   service, which will pull the environment-specific tag
4. Push the git release branch matching the environment name to the same commit
   as the given version tag

A developer can then manually start a release to Staging then Production,
passing the same version tag as a parameter OR the "intg" branch/tag
name.

[tdr-api]: https://github.com/nationalarchives/tdr-consignment-api
[frontend]: https://github.com/nationalarchives/tdr-transfer-frontend

### Version numbers

The version numbers will come from Jenkins build numbers, rather than using a
semantic versioning system. This is because semantic versions aren't as
meaningful for applications as for libraries, and because updating the minor or
major version would need a developer to bump the version number. It's more
useful to have an auto-incrementing version number generated by something like
Jenkins.

If the build numbers are ever reset, for example because we rebuild Jenkins from
scratch, we can set the next build numbers so they start from the next version
rather than resetting back to build 1. To do this, you can run a script in the
[Jenkins script console][script-console]:

```
def job = Jenkins.instance.getItemByFullName("name-of-jenkins-build/master")
job.nextBuildNumber = 123
job.save()
```

[script-console]: https://jenkins.tdr-management.nationalarchives.gov.uk/script

### Docker retagging step

The process described above is slightly inefficient, because the deployment
build needs to pull the Docker image tagged with the version number, retag it
with the environment name, and then push it back to Docker Hub. This is because
there's currently no simple way to add a new tag to a remote image without
pulling and pushing it.

Docker Hub might support this in the future, which would make the deployment
step slightly faster. Alternatively, [AWS ECR supports image
retagging][ecr-retag], so this step would be simpler when we switch to ECR.

[ecr-retag]: https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-retag.html
