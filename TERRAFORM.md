# Terraform Documentation

* Prototype Stateful Project: https://github.com/nationalarchives/tdr-prototype-terraform-stateful
* Prototype Modules Project: https://github.com/nationalarchives/tdr-prototype-terraform-modules
* Prototype Project: https://github.com/nationalarchives/tdr-prototype-terraform (archived)


## Project Structure

The TDR Terraform project is divided into two main sets of components:
* Stateful: [github repo link]
* Modules: [github repo link]

This supports the environments for TDR:
* development (dev)
* test (test)
* production (prod)

## Stateful

* *Question: use Terraform workspaces?*
* *Question: how to set up the Terraform backend (bootstrapping vs manual set up) ?*

This contains the configuration for the different environments required.

Terraform needs to keep track of the resources it creates to allow it to know which:
* real-life resource(s) is being changed when a resource is altered in a template;
* resource(s) to destroy when the a terraform destroy command is run.

By default, the terraform state is stored in a local folder `.terraform`. However, storing the state locally will mean it is inaccessible to other administrators.

To overcome this the current Terraform state is stored in an s3 bucket with a DynamoDB table to record the lock status. Using a DynamoDB table ensures that the state files are locked, whilst updating is being done.

### Terraform Backends - Persisting “State”

To preserve the Terraform state an s3 bucket needs to be created to store the /terraform.tfstate file that is generated by Terraform when applying the scripts. For example:

 ```
 terraform { 
    backend "s3" {
    bucket         = "tdr-prototype-terraform-state"
    key            = "prototype-terraform/stateful/dev/terraform.tfstate"
    region         = "eu-west-2"
    encrypt        = true
    dynamodb_table = "terraform-statelock-tdr-prototype"
    #profile        = "terraform"
  }
}
```


* **bucket**: the s3 bucket name where the Terraform state will be stored
* **key**: path to the Terraform state file inside the bucket.

To record the lock status a DynamoDB table is needed.

* **dynamodb_table**: name of the DynamoDB table where the lock will be stored

The DynamoDB table should have “LockID” set as its “Primary Key”. The primary key needs to be  set when the DynamoDB table is created.

Both the s3 bucket(s) and DynamoDB table(s) need to be created before the Terraform scripts can be run.

### Useful Resources
* https://www.terraform.io/docs/backends/index.html
* Bootstrapping the backend: https://www.monterail.com/blog/chicken-or-egg-terraforms-remote-backend

##Modules

Modules are containers for multiple resources that are used together.

For each new module that is needed a new GitHub repository should be created. This allows for clear versioning of the infrastucture, which in turns makes it easier to deploy new versions to lower environments for validation, before promotion to higher environments

Within the module the relevant GitHub version can then be referenced as the sources. For example:

```
module "cognito_admin" {
source = "git@github.com:nationalarchives/terraform-modules.git//cognito?ref=prod"
  ...
}
```
Here the module version for production (prod) is is referenced through the source attribute. In the development environment the module version for development would be referenced.

Useful Resources:
* https://www.oreilly.com/library/view/terraform-up-and/9781491977071/ch04.html
* https://www.terraform.io/docs/modules/index.html

## Git Hub Repositories Structure

For an example structure for Terraform architecture see the following GitHub repositories used by Digital Services:
* Stateful repository: https://github.com/nationalarchives/Terraform-Stateful
* Modules repository: https://github.com/nationalarchives/terraform-modules

### Stateful

Url: https://github.com/nationalarchives/tdr-prototype-terraform-stateful

This repository should contain the configuration for setting up the infrastructure using modules contained in the modules repository.

### Modules

Url: https://github.com/nationalarchives/tdr-prototype-terraform-modules

This repository should contain the reusable modules, across environments that are used to provision the resources which are referenced by the stateful Terraform repository.

Will have branches to mirror the different environments required. For example:
* dev;
* testing;
* live.

Each individual module will have a separate folder within the repository.

## Cloning GitHub Modules

Where the module source is a GitHub repository, Terraform will clone the specified repository. To enable cloning GitHub credentials are needed.

## Coding Guidelines

### Tagging of Resources

Resources that are provisioned MUST BE tagged. This allows other users and systems adminstrators to understand who owns the resources.

See here for standards for tagging: https://github.com/nationalarchives/tna-aws-tagging-naming

For tagging of resources in TDR the following convention should be followed:

```
tdr-{serviceCode}-{applicationTypeCode}-{environmentCode}-{resource}-{role}
```

Service Codes:

[TODO]

Application Type Codes:

[TODO]

Environment Codes:
* dev
* test
* live

### Terraform Style Conventions

See the following for style conventions: https://www.terraform.io/docs/configuration/style.html

### Module Structure

The recommended structure for a module is:

- /module1
-- /main.tf
-- /outputs.tf
-- /variables.tf

#### /main.tf

Primary entry point for the module, and may be where all the resources for the module are created. Can be empty

#### /outputs.tf

This file will contain the declarations for any module values that needed to be exposed to any other modules within the infrastructure.

#### /variables.tf

Contains the variable declarations for the module.

## Testing Frameworks

* *Question: Is testing of the Terraform framework necessary?*

Two frameworks
* Terratest: GO open source library (under the Apache 2.0 license) - https://github.com/gruntwork-io/terratest#testing-best-practices
* Kitchen-Terraform:  open source set of Test Kitchen plugins for testing Terraform configuration -  https://newcontext-oss.github.io/kitchen-terraform/

## Further Resources

### Terraform

* Basic Terraform tutorial: https://learn.hashicorp.com/terraform/#getting-started
* Guide to setting up AWS resources:  https://www.terraform.io/docs/providers/aws/

### Using Terraform Workspaces to Manage Multiple Environments

* https://medium.com/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622
* https://dzone.com/articles/manage-multiple-environments-with-terraform-worksp

### Testing Terraform

* https://www.contino.io/insights/top-3-terraform-testing-strategies-for-ultra-reliable-infrastructure-as-code
* https://www.terraform.io/docs/extend/testing/unit-testing.html (Unit testing)

#### Kitchen Framework

* https://newcontext-oss.github.io/kitchen-terraform/getting_started.html
* https://www.darkraiden.com/blog/test-terraform-with-kitchen-and-awspec/

#### Terratest Framework

* https://winderresearch.com/how-to-test-terraform-infrastructure-code/
* https://github.com/gruntwork-io/terratest/tree/master/examples/terraform-aws-ecs-example
* https://github.com/gruntwork-io/terratest/blob/master/test/terraform_aws_ecs_example_test.go
* https://brightfame.co/blog/testing-your-terraform-project-with-terratest/
